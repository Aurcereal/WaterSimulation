Unity, ShaderLab, C#

[Used unity as graphics programming environment]
[Wrote SDF engine to interact with water sim]

https://matthias-research.github.io/pages/publications/sca03.pdf
https://sph-tutorial.physics-simulation.org/pdf/SPH_Tutorial.pdf
http://www.ligum.umontreal.ca/Clavet-2005-PVFS/pvfs.pdf

gridsize = h/sqrt(2)

write about optimizations to run in realtime

Seb Lague Vid

THE FOAM ISNT DISAPPEARING FAST ENOUGH

- Maybe group water particle into struct with position and velocity
- Group density and neardensity as a float2 (less reads and writes)
- Probably just take out masses for now?
- Implement linked list method for springs (detailed below)

- Better foam rendering with volumetric raymarching as described by first foam paper (neighbor search terminates at first find so not so bad)
- Caustics (nvidia article scroll up)
- God rays??

- Extreme viscosity so like a fluid box will stay together (very very strong springs?)
- Can turn a arb mesh into fluid so it'd be kinda like soft body sim lol

- eventually could make like a water slide or something with sdfs
- tinted glass could also be really nice, prolly wouldn't be hard since it's just perfect reflect and perfect transmit.. like prolly is extremely similar to water actually mabe with different base reflectance

- Have presets to choose what type of fluid you want with presets affecting material and sim
- Preset situations with SDF objects to play with (water slide stuff, fountain with artificial force and stuff would be really cool)
- potential scenes:
	Water slide spiral
	Fountain with artificial force.. what if the water was like actually recycled and went back up the elevator... like cylindrical container open top oc and inner radial force as you get closer to edge of container and closer to floor, then upward force drastically goes up when u get close to sdf cylinder in middle (invisible cylinder), we don't need any geometry for the fountain, or just like very minimal geometry
	Pouring water glass (or cup cuz i dont wanna write glass material for 1 scene)
	Filling up bath with SDF toys around to splash inside
	Hamburger ketchup very viscous on simple hamburger with bun (since it's all SDF) and mabe hamburger closes.. very little ketchup needed
	Honey
	Attractor Ball
	Regular simple container scene in the sky or wherever different hdris, spawn a way to produce nice waves and stuff, show slowly putting in the object and lifting it back out - the simple container scene is good for showcasing foam, caustics, shadows, the 35, 8, 8 default container
- 3D Object Repeller/Attractor objects or can use raycasting to transfer mouse force to 3D
- Sticky magnet with springs, different types of liquids like ketchup or goop could be cool visuals
- Could eventually move to SDY and have water interact with SDF objects there
- Make a new branch where you're fixing stuff/adding preset stuff and can use scriptable objects for presets of scenes and another set of scriptable objects for presets of materials
- Maybe 5 SOs: Scene (includes floor pattern), Fluid Visual Material, Fluid Behavior Preset, Foam Material/Behavior in 1 SO, Caustics Material?
	Need a toggle for Foam, Caustics, Shadow Mapping/Occlusion, 3 Render Modes: (Balls, Raymarched, Screenspace)
	Need a toggle for Springs, Stickiness

Honey Funnel, Ketchup on burger maybe put on and then smashed (would have to be very little liquid to achieve sticking and also stick force would help ig), Water slide spiral, Attractor ball demo moves around on its own or smth - maybe it goes down, picks up some water through attraction, goes back up, then suddenly turns off attractor and the water falls back down

-=Ignore/Done for now=-

https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf
https://developers.redhat.com/articles/2024/08/15/your-first-gpu-algorithm-scanprefix-sum#prefix_sum rly good explanation
For count sort we need an efficient way to do prefix sum this article has good explanation

- For Wave Crest we need easy access to normals i guess i can precompute it foreach... even though it'd be kinda expensive?
	- Well it can be toggleable
	- Do it all in one loop is nice multiple loops make things worse, can really calculate new normal in the same loop im using the prev normals

- Flip fluid implementation mode? downloaded paper on it

- Collisions with sdf objects considering velocities from one of those papers? idk not that important mabe
	- Simple way would just be adding the velocity of the object with a multiplier, maybe make wrt density.. prolly should make bounce off velocity like that too anyways

- Try using golf and unsafe versions of smoothing kernels/gradients
- Surface Tension from one of those papers (didn't turn out well for now..)
- Springs are a big nxn matrix currently, that can get massive so can cut down to an 'adjacency list' which will just be stored as like an nx200 matrix where row i stores particles that are within smoothing distance of particle i (since it won't be much).  Can store length for each row.
- Elasticity from ligum paper section 5 (implemented)
- Sim Parameters has 'Initialization' header section with particle count, spawn zone... etc... and whether to use springs (so we can avoid creating big buffer sometimes)
- Rectangle w/ Arb transform Collision (or just sdfs lol)
- Try SDF stickiness (Clavet 6.2 maybe can ignore fact that my collision resolution is very simpler just add sticky force)

-=-=-=-

Different buttons linking to different parts of same page
Emphasize compute shader stuff and graphics programming related stuff, optimizations and realtime gpu utilization stufff







-=-=-=-=-

Used these papers and this video

The water is simulated using about one hundred thousand SPH fluid particles.  Interactions between water particles simulate the particles being radially 'blurred' so that the behavior is more smooth and water-like and less like a ton of discrete particles.  The most important factor for this simulation being water-like was computing a pressure gradient (for any given point, we calculate a vector that goes from high water density to low water density).  This allowed water to flow from high density to low density.  I also implemented some other forces from various papers to make the water behave more nicely: viscosity, spring forces between the water particles, and a stickiness force so that particles stuck to non-particle objects in the scene.

I used compute shaders for updating the velocities and positions of the particles.  Each thread in a work group was designated to update a single particle.  For a given particle, to compute its interaction forces, we need to get all of the particles within a user-changeable 'particle interaction radius'.  To avoid having a single compute thread iterating over every other particle in the simulation and tanking performance, I used a spatial hashing method as described by this paper: (dont say 'this paper' also insert it here).  This method splits 3D space into grid cells and randomly assigns each cell an integer key (different cells can have the same key).  For each particle, we assign it the key of the cell it's in.  Then, in the array of particles, through sorting, we group particles with the same key so that all particles in the same grid cell are together.  The main idea of the method is that this grouping that allows us to iterate through all particles in a given cell, which allows us to search the grid cells around a given particle instead of iterating through every other particle.  Since some different cells will have the same key, searching for particles in a grid cell may result in unwanted particles from other cells, but this is okay since the important part is that we find the particles that we want, we can just ignore particles that aren't within the 'particle interaction radius'.

For the sorting described in the spatial hashing above, I tried a Bitonic Sort using Compute Shaders, which worked pretty well, but I saw some people saying that using a convergent sort like Odd-Even was better since it's a convergent sort and the work can be split across multiple frames (with the downside of not always being completed sorted but that's probably okay in this case since the sim doesn't need to be exact).  I tried implemented Odd-Even sort and ...



For rendering, I tried 2 methods: Raymarched Rendering and Screenspace Rendering (as described by this paper: INSERT HERE)

Talk about bitonic sort and if you do prefix sum on gpu cuz these are like gpu programming algos
Implemented bitonic sort and count sort on GPU O(lgn) for count sort and like O(lg^2n) for bitonic

emphasize all the optimization effort