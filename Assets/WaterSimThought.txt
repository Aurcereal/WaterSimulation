Unity, ShaderLab, C#

[Used unity as graphics programming environment]
[Wrote SDF engine to interact with water sim]

https://matthias-research.github.io/pages/publications/sca03.pdf
https://sph-tutorial.physics-simulation.org/pdf/SPH_Tutorial.pdf
http://www.ligum.umontreal.ca/Clavet-2005-PVFS/pvfs.pdf

gridsize = h/sqrt(2)

write about optimizations to run in realtime

Seb Lague Vid

Would be good to render SDF depth before rendering screenspace density so fluid behind SDF object doesn't contribute to density, this is particularly bad on the spiral slide environment

- Maybe group water particle into struct with position and velocity
- Group density and neardensity as a float2 (less reads and writes)
- Probably just take out masses for now?
- Implement linked list method for springs (detailed below)

- Better foam rendering with volumetric raymarching as described by first foam paper (neighbor search terminates at first find so not so bad)
- Caustics (nvidia article scroll up)
- God rays??

- Extreme viscosity so like a fluid box will stay together (very very strong springs?)
- Can turn a arb mesh into fluid so it'd be kinda like soft body sim lol

- eventually could make like a water slide or something with sdfs
- tinted glass could also be really nice, prolly wouldn't be hard since it's just perfect reflect and perfect transmit.. like prolly is extremely similar to water actually mabe with different base reflectance

- Have presets to choose what type of fluid you want with presets affecting material and sim
- Preset situations with SDF objects to play with (water slide stuff, fountain with artificial force and stuff would be really cool)
- potential scenes:
	Water slide spiral
	Fountain with artificial force.. what if the water was like actually recycled and went back up the elevator... like cylindrical container open top oc and inner radial force as you get closer to edge of container and closer to floor, then upward force drastically goes up when u get close to sdf cylinder in middle (invisible cylinder), we don't need any geometry for the fountain, or just like very minimal geometry
	Pouring water glass (or cup cuz i dont wanna write glass material for 1 scene)
	Filling up bath with SDF toys around to splash inside
	Hamburger ketchup very viscous on simple hamburger with bun (since it's all SDF) and mabe hamburger closes.. very little ketchup needed
	Honey
	Attractor Ball
	Regular simple container scene in the sky or wherever different hdris, spawn a way to produce nice waves and stuff, show slowly putting in the object and lifting it back out - the simple container scene is good for showcasing foam, caustics, shadows, the 35, 8, 8 default container
- 3D Object Repeller/Attractor objects or can use raycasting to transfer mouse force to 3D
- Sticky magnet with springs, different types of liquids like ketchup or goop could be cool visuals
- Could eventually move to SDY and have water interact with SDF objects there
- Make a new branch where you're fixing stuff/adding preset stuff and can use scriptable objects for presets of scenes and another set of scriptable objects for presets of materials
- Maybe 5 SOs: Scene (includes floor pattern), Fluid Visual Material, Fluid Behavior Preset, Foam Material/Behavior in 1 SO, Caustics Material?
	Need a toggle for Foam, Caustics, Shadow Mapping/Occlusion, 3 Render Modes: (Balls, Raymarched, Screenspace)
	Need a toggle for Springs, Stickiness

Honey Funnel, Ketchup on burger maybe put on and then smashed (would have to be very little liquid to achieve sticking and also stick force would help ig), Water slide spiral, Attractor ball demo moves around on its own or smth - maybe it goes down, picks up some water through attraction, goes back up, then suddenly turns off attractor and the water falls back down

-=Ignore/Done for now=-

https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf
https://developers.redhat.com/articles/2024/08/15/your-first-gpu-algorithm-scanprefix-sum#prefix_sum rly good explanation
For count sort we need an efficient way to do prefix sum this article has good explanation

- For Wave Crest we need easy access to normals i guess i can precompute it foreach... even though it'd be kinda expensive?
	- Well it can be toggleable
	- Do it all in one loop is nice multiple loops make things worse, can really calculate new normal in the same loop im using the prev normals

- Flip fluid implementation mode? downloaded paper on it

- Collisions with sdf objects considering velocities from one of those papers? idk not that important mabe
	- Simple way would just be adding the velocity of the object with a multiplier, maybe make wrt density.. prolly should make bounce off velocity like that too anyways

- Try using golf and unsafe versions of smoothing kernels/gradients
- Surface Tension from one of those papers (didn't turn out well for now..)
- Springs are a big nxn matrix currently, that can get massive so can cut down to an 'adjacency list' which will just be stored as like an nx200 matrix where row i stores particles that are within smoothing distance of particle i (since it won't be much).  Can store length for each row.
- Elasticity from ligum paper section 5 (implemented)
- Sim Parameters has 'Initialization' header section with particle count, spawn zone... etc... and whether to use springs (so we can avoid creating big buffer sometimes)
- Rectangle w/ Arb transform Collision (or just sdfs lol)
- Try SDF stickiness (Clavet 6.2 maybe can ignore fact that my collision resolution is very simpler just add sticky force)

-=-=-=-

Different buttons linking to different parts of same page
Emphasize compute shader stuff and graphics programming related stuff, optimizations and realtime gpu utilization stufff







-=-=-=-=-

Used these papers and this video

The water is simulated using about one hundred thousand SPH fluid particles.  Interactions between water particles simulate the particles being radially 'blurred' so that the behavior is more smooth and water-like and less like a ton of discrete particles.  The most important factor for this simulation being water-like was computing a pressure gradient (for any given point, we calculate a vector that goes from high water density to low water density).  This allowed water to flow from high density to low density.  I also implemented some other forces from various papers to make the water behave more nicely: viscosity, spring forces between the water particles, and a stickiness force so that particles stuck to non-particle objects in the scene.

I used compute shaders for updating the velocities and positions of the particles.  Each thread in a work group was designated to update a single particle.  For a given particle, to compute its interaction forces, we need to get all of the particles within a user-changeable 'particle interaction radius'.  To avoid having a single compute thread iterating over every other particle in the simulation and tanking performance, I used a spatial hashing method as described by this paper: (dont say 'this paper' also insert it here).  This method splits 3D space into grid cells and randomly assigns each cell an integer key (different cells can have the same key).  For each particle, we assign it the key of the cell it's in.  Then, in the array of particles, through sorting, we group particles with the same key so that all particles in the same grid cell are together.  The main idea of the method is that this grouping that allows us to iterate through all particles in a given cell, which allows us to search the grid cells around a given particle instead of iterating through every other particle.  Since some different cells will have the same key, searching for particles in a grid cell may result in unwanted particles from other cells, but this is okay since the important part is that we find the particles that we want, we can just ignore particles that aren't within the 'particle interaction radius'.

For the sorting described in the spatial hashing above, I tried a Bitonic Sort using Compute Shaders, which worked pretty well, but I saw some people saying that using a convergent sort like Odd-Even was better since it's a convergent sort and the work can be split across multiple frames (with the downside of not always being completed sorted but that's probably okay in this case since the sim doesn't need to be exact).  I tried implemented Odd-Even sort and ...



For rendering, I tried 2 methods: Raymarched Rendering and Screenspace Rendering (as described by this paper: INSERT HERE)

Talk about bitonic sort and if you do prefix sum on gpu cuz these are like gpu programming algos
Implemented bitonic sort and count sort on GPU O(lgn) for count sort and like O(lg^2n) for bitonic

emphasize all the optimization effort

-=-=-=-
(MAKE THE IMPORTANT TERMS BOLD SO AT A GLANCE U SEE ALL THE FEATURES, DONT BOLD OTO MUCH CUZ tHAT DESTROYS PURPOSE)
normalize terms like water vs fluid and raymarching vs ray marching etc
During the summer of 2025, I made a realtime fluid simulation and renderer in Unity.  The features include

	- Particle-Based Fluid Simulation based on Smoothed Particle Hydrodynamics (SPH) run using Compute Shaders
	- Physically Based Raymarched Fluid Renderer written with HLSL
	- Physically Based Screenspace Fluid Renderer written with HLSL (faster than raymarched but not as accurate)
	- Particle-Based Foam Simulation for crashing waves run using Compute Shaders
	- Foam rendering using using volumetric raymarching or billboard sprites written with HLSL
	- Shadows Rendered using either shadow maps or raymarching
	- Caustics Rendered using deferred rendering-like techniques or raytracing (mention nvidia article and how i extended it to screenspace)
	- Spatial Hashing and different GPU sorting algorithms to allow the simulation to run at high framerates

-=-=-=- Demo -=-=-=-

Show stuff next

This project taught me a lot about GPU programming, PBR, and SPH Fluid Simulation.  I started this project after I was inspired by two videos from Sebastion Lague (link) on simulating and rendering fluids.  His video and the following papers were very helpful (write the paper and what it helped with).  More implementation details on the project below

-=-=-=- Particle Simulation -=-=-=-

I started by creating a particle simulation with a simple gravity force.  In order to make the particles more fluid like, they need to interact, so we need to be able to compute a pressure force.  I used a technique from Smoothed Particle Hydrodynamics where each discrete particle becomes radially 'blurred'.  Each particle represents a small spherical volume of fluid rather than a volumeless point with mass.  We then represent the particle world with a density field, where we want to be able to sample any position and get the density at that position.  In order to sample this density field efficiently, we need to iterate over all particles near our sample point and add their density contribution.  This is done using a technique called Spatial Hashing; it splits the world into grid cells and uses ideas similar to Worley Noise and Hashmaps, more information can be found from this paper (INSERT).  This technique also needs to sort over all particles in the world, which became a hard performance bottleneck when I put the simulation on the GPU.  After we have our density field, we compute our gradient vector field (the direction in which the density increases the fastest).  Fluid generally flows from high density to low density, so we can apply a force against the gradient to make the behavior of the particles more fluid-like.  More information on the pressure force can be found from this paper (INSERT).

I previously wrote the particle simulation in C#, so in order to put it on the GPU, I had to rewrite it using compute shaders.  Converting the logic was mostly straightforward, except for the sorting of the particles required in Spatial Hashing.  I implemented Bitonic Sort and Count Sort on the GPU for this.

I used SDFs for the particle environment and so that I could easily interact with the particles.  Here's a demo of the particle simulation with an invisible sphere interacting (we'll describe how to render the water and the environment below).

-=-=-=- Fluid Rendering -=-=-=-

To render our fluid particles in a way that looks like fluid, I used two different techniques: raymarching, and a screenspace technique from a (GDC PRESENTATION??).
I implemented the raymarching technique first.  It works by taking the density field from the simulation, caching it in a texture every frame, and using a fullscreen shader to raymarch the cached density field.  We shoot rays out from the camera, refract and reflect them on the water using Fresnel's law, calculate the density along rays going through the water, and compute how light is extinguished from the sun to the camera.  I used a lot of techniques I learned from the pathtracer and realtime renderer I made, along with information from This (PAPER FRESNEL FROM SEBLAGUE).

While raymarching looked nice, it did cause a decrease in framerate when the bounding box in which we cache densities and render was too large.  In order to have high framerates and be able to have the fluid rendered anywhere, I used a technique from (GDFCF WHAT ??!? forget what its' called) presentation called screenspace fluid rendering.  It works using a deferred-rendering-like setup with multiple render passes.  We start by rendering the depths of the particles as spheres from the camera (this can be done more efficiently quads by having the quads render depths as camera-oriented spheres).  Once we have that depth texture, we apply a world space Gaussian blur, but make it so pixels that are far apart in depth aren't blurred together as much.  This makes it so only the parts of the depth texture that represent geometry actually close to each other are blurred.  We use this blurred depth texture as a representation of our visible water geometry.  We run another shader pass to compute normals from our blurred depth texture.  We can also get positions from depths.  Then, we need to get the density along each ray that's sent out from the camera that refracts through the water.  For this, we can render our particles at a low opacity in an additive way, so parts of the screen that have lots of particles will be closer to having full alpha.  This isn't perfect since it doesn't simulate how rays bend through water.  With the normals and positions of our blurred geometry and the density along our camera rays, we can apply our water PBR techniques to render like how we did in the raymarching shader.  It's faster than raymarched and fluid can be rendered anywhere, but it doesn't look as good and we can only have a single ray bounce whereas we could have as many as we want with raymarched.

Both rendering techniques are good for different use cases.  For each of the rendering techniques, I made an SDF Renderer to render a customizable environment around the fluid.  Here are some of the visual demos I made using these environments and SDF interactions with the fluid.

-=-=-=- Foam Simulation and Rendering -=-=-=-

(have a billboard and volume demo of u turning stuff on, u need to show turning features on gradually or smth, also a screenspace foam demo)
To get an appearance of crashing waves, I added foam to the simulation.  When fluid particles have a lot of kinetic energy or are crashing into each other, they generate foam particles.  The foam particles are simulated with compute shaders; they act as rising bubbles beneath the water, foam on the water, and spray when outside of the water.  Many of the techniques I used come from (PAPER).
I first tried rendering the foam as many camera-oriented billboard sprites.  This was good for performance but didn't look that good to me, so I tried rendering them using volumetric raymarching based on (THIS PAPER).  To do this, I had to use the Spatial Hashing technique described earlier for the foam particles.  I liked the result of using both billboard rendering and raymarched rendering.  The screenspace water mode only supports billboard foam while raymarched water mode supports both.  Here are some demos of the foam being simulated and rendered in the raymarched and screenspace mode.


-=-=-=- Shadows -=-=-=-

Shadow mapping and raymarched shadows

(cut down stuff like why say matrix who cares)
I also implemented shadows in the environment around the fluid.  I had two different implementations for the raymarched fluid mode and the screenspace fluid mode.  For the raymarching mode, when a ray samples the SDF environment, I send a raymarched ray to the sun to see how much light from the sun gets extinguished through the fluid.  For the screenspace rendering mode, without raymarching, I used shadowmapping.  I re-used the code from when the screenspace rendering mode gets how much density is along each camera ray in a texture by rendering the particles with low opacities in an additive way, except this time, I rendered that texture from the sun, to act as a shadow map.  I then used a view projection matrix when rendering the SDF environment to add shadow mapping to the screenspace fluid mode.  Here are some demos of the shadows in both rendering modes.

-=-=-=- Caustics -=-=-=-

Screenspace and raymarched

After shadows, I implemented caustics, the visual result of light refracting through the surface of fluid.  Like shadows, this had two separate implementations in the screenspace rendering mode and the raymarching rendering mode.  For the raymarching rendering mode, I referenced this (NVIDIA CAUSTICS ARTICLE).  When a ray samples a point in the SDF environment, it checks if it's in the fluid, and if it is, it samples caustics light by shooting a ray along its normal (in a more realistic renderer, we'd shoot out a lot more rays, but the ray along the normal will likely get the most light because of Lambert's law) and refracting the ray on the surface of the water, and finally, seeing how close that ray is to the sun direction.  
The screenspace rendering implementation is very similar, except for how we get information on how the ray refracts through the water; since we can't use raymarching.  We assume the floor is flat so all the rays we're shooting are along the y-axis.  We then render the positions and normals of the top of the water and use that information to calculate where and how the ray we shoot refracts through the water.
Here are some demos of the caustics in both rendering modes.

-=-=-=-

link repo on website and link website on repo and have description on repo readme w screenshots

Will need a lot of mp4 to gif conversions for website

Breakdown -

Pretty basic overview that demos simulation with the balls then screenswipes between raymarching to screenspace in the raymarched scene where we have foam, shadows, and caustics then can show a couple other fav scenes while subtitles explain a bit more in depth of how it works and stuff like the top part of the script plan

SCRAPPED:

I started by creating a particle simulation with a simple gravity force.  In order to make the particles more fluid like, they need to interact, so we need to be able to compute a pressure force.  I used a technique from Smoothed Particle Hydrodynamics where each discrete particle becomes radially 'blurred'.  Each particle represents a small spherical volume of fluid rather than a volumeless point with mass.  We then represent the particle world with a density field, where we want to be able to sample any position and get the density at that position.  To do this, when we sample a point, we can iterate over all particles near that point and add up their density contribution, which can be calculated using a radial smoothing function (the smoothing creates our blur).  The smoothing function is just a decreasing function of the distance between sample point and particle.  The technique that allows us to iterate over all particles near our sample point instead of every particle in the world (which would be way slower) is called Spatial Hashing; it splits the world into grid cells and uses ideas similar to Worley Noise and Hashmaps, more information can be found from this paper (INSERT).  This technique also needs to sort over all particles in the world, which became a hard performance bottleneck when I put the simulation on the GPU.

After we have our density field, we want to compute the gradient field (the direction in which the density increases the fastest).  Since our density is computed by adding up the samples of every nearby particles' smoothing function, we can compute the gradient by adding up the samples of every particle's smoothing function's gradient (which can be derived analytically).  Fluid generally flows from high density to low density, so we can apply a force against the gradient to make the behavior of the particles more fluid-like.  More information on the pressure force can be found from this paper (INSERT).  I also used some other papers to implement other forces to make the particles more fluid-like; these include a spring force, a stickiness force (for props in the world), and a viscosity force.

For the screenspace rendering mode, without raymarching, assuming the floor was flat, I rendered the positions and normals of the top of the water, then, when we render a point in the SDF environment that's inside the fluid, we can imagine shooting a ray along the normal (we're assuming the surface is flat so the normal points up along the y axis) and using the info on the top of the water to see how that ray refracts out of the water and comparing it with the sun direction.

