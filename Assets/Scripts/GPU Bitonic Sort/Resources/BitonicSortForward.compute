#pragma kernel SortPass

struct ParticleEntry {
    int particleIndex;
    int key;
};

RWStructuredBuffer<ParticleEntry> ParticleEntries;
const uint EntryCount;
const uint NextPowerOf2EntryCount;
const uint GroupSize;
const uint AlternatorGroupSize; // We alternate direction of compare every AlternatorGroupSize indices

/// This is the normal bitonic sort, but we only sort forward.  
/// Every sequence S that should've been sorted backwards is accessed differently like: S.get(i) = S[S.length - 1 - i]
/// We use the 'lastAlternatorSize' to determine whether a subsequence should've been sorted forward or backwards
[numthreads(64,1,1)]
void SortPass (uint3 id : SV_DispatchThreadID)
{
    // We only need at most NextPowerOf2EntryCount/2 compares total
    uint i = uint(id.x);
    if(i >= NextPowerOf2EntryCount/2) return;

    //
    uint halfGroupSize = GroupSize*0.5;

    // We need GroupSize/2 compares per group
    uint group = i / halfGroupSize;
    uint indexInGroup = i % halfGroupSize;

    //
    uint thisIndex = GroupSize * group + indexInGroup;
    uint otherIndex = thisIndex + halfGroupSize;

    uint lastAlternatorSize = AlternatorGroupSize/2;
    if(thisIndex/lastAlternatorSize % 2 == 1) thisIndex = GroupSize * group + halfGroupSize-1-indexInGroup;
    if(otherIndex/lastAlternatorSize % 2 == 1) otherIndex = GroupSize * group + halfGroupSize-1-indexInGroup + halfGroupSize;;

    if(otherIndex >= EntryCount) return;

    ParticleEntry thisEntry = ParticleEntries[thisIndex];
    ParticleEntry otherEntry = ParticleEntries[otherIndex];

    if(thisEntry.key > otherEntry.key) {
        // Swap
        ParticleEntries[thisIndex] = otherEntry;
        ParticleEntries[otherIndex] = thisEntry;
    }

}
