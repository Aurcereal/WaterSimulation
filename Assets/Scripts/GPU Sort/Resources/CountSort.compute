#pragma kernel ResetCounts
#pragma kernel SetCounts
#pragma kernel SortParticles
#pragma kernel CopyFromSortedBufferToEntryBuffer

#pragma multi_compile BUFFER_COUNT __

struct ParticleEntry {
    int particleIndex;
    int key;
};

RWStructuredBuffer<ParticleEntry> ParticleEntries;
RWStructuredBuffer<ParticleEntry> ParticleEntriesSorted;
RWStructuredBuffer<int> KeyCounts;

#ifdef BUFFER_COUNT
RWStructuredBuffer<uint> CountBuffer; // Make sure Count is in index 0
#else
const uint ParticleCount;
#endif
const uint SpatialLookupSize;

[numthreads(64,1,1)]
void ResetCounts (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(i >= SpatialLookupSize) return;

    KeyCounts[i] = 0;
}

[numthreads(64,1,1)]
void SetCounts (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    #ifdef BUFFER_COUNT
    if(i >= CountBuffer[0]) return;
    #else
    if(i >= ParticleCount) return;
    #endif

    InterlockedAdd(KeyCounts[ParticleEntries[i].key], 1);
}

[numthreads(64,1,1)]
void SortParticles (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    #ifdef BUFFER_COUNT
    if(i >= CountBuffer[0]) return;
    #else
    if(i >= ParticleCount) return;
    #endif

    ParticleEntry entry = ParticleEntries[i];

    uint placementIndex;
    InterlockedAdd(KeyCounts[entry.key], 1, placementIndex);
    ParticleEntriesSorted[placementIndex] = entry;
}

[numthreads(64,1,1)]
void CopyFromSortedBufferToEntryBuffer (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    #ifdef BUFFER_COUNT
    if(i >= CountBuffer[0]) return;
    #else
    if(i >= ParticleCount) return;
    #endif

    ParticleEntries[i] = ParticleEntriesSorted[i];
}

