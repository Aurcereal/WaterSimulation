#pragma kernel CalculatePredictedPositions

#pragma kernel UpdateSpatialHashEntries
#pragma kernel ResetSpatialHashOffsets
#pragma kernel UpdateSpatialHashOffsets // Must be sorted at this point

#pragma kernel CalculateDensities
#pragma kernel UpdateParticles

//
RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> predictedPositions;
RWStructuredBuffer<float2> velocities;

RWStructuredBuffer<float> masses;

RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> nearDensities;

RWStructuredBuffer<float4> colors;

// Simulation Params
const int ParticleCount;
const float2 BoxDimensions;
const float BoxThickness;
const float2 Gravity;
const float ParticleRadius;
const float SmoothingRadius;
const float MouseForceRadius;
const float MouseForceStrength;
const float TargetDensity;
const float NearDensityPressureMultiplier;
const float PressureMultiplier;
// how to do gradients? seb lag idk what they did or i could just do gradient texture.. grad to tex?
const float ViscosityStrength;
const float SurfaceTensionMultiplier;

//
const float GridSize;
const int SpatialLookupSize;

//
const float DeltaTime;

//
const float MouseForceSign;
const float2 MousePosition;

//
#include "./ParticleMath.hlsl"
#include "./SpatialHash.hlsl"

///
[numthreads(64, 1,1)]
void CalculatePredictedPositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    predictedPositions[i] = positions[i] + velocities[i] * (1.0/60.0);
}

[numthreads(64, 1,1)]
void UpdateSpatialHashEntries (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    int2 cell = posToCell(predictedPositions[i]);
    int key = getCellKey(cell);

    ParticleEntry e;
    e.particleIndex = i;
    e.key = key;

    particleCellKeyEntries[i] = e;
}

[numthreads(64, 1, 1)]
void ResetSpatialHashOffsets(uint3 id : SV_DispatchThreadID) {
    int i = id.x;
    if(i >= SpatialLookupSize) return;

    cellKeyToStartCoord[i] = -1;
}

[numthreads(64, 1,1)]
void UpdateSpatialHashOffsets (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // Check if the current index in the Particle Array is a start index
    if(i==0) {
        ParticleEntry e = particleCellKeyEntries[0];
        cellKeyToStartCoord[e.key] = i;
    } else {
        ParticleEntry eCurr = particleCellKeyEntries[i];
        ParticleEntry ePrev = particleCellKeyEntries[i-1];

        if(eCurr.key != ePrev.key) {
            cellKeyToStartCoord[eCurr.key] = i;
        }
    }
}

[numthreads(64, 1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    float totalDensity = 0.0;
    float totalNearDensity = 0.0;

    float2 pos = predictedPositions[i];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int particleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    particleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    totalDensity += masses[particleIndex] * SmoothingKernelPow2(SmoothingRadius, length(predictedPositions[particleIndex] - pos));
                    totalNearDensity += masses[particleIndex] * SmoothingKernelPow3(SmoothingRadius, length(predictedPositions[particleIndex] - pos));

                    currIndex++;
                }
            }
        }
    }

    densities[i] = totalDensity;
    nearDensities[i] = totalNearDensity;
}

float DensityToPressure(float density)
{
    // TargetDensity kind of offsets pressure to determine what happens with empty space: 
    // if the result is high, our gradient will go from empty to wherever this is, 
    // if our result is low, our gradient will go from wherever this is to empty
    return PressureMultiplier * (density - TargetDensity);
}

float NearDensityToPressure(float nearDensity)
{
    // It's always a repelling force we 'want' the near density to be 0
    return NearDensityPressureMultiplier * nearDensity;
}

// Pressure force is -PressureGradient since we'll flow from high pressure to low pressure
float2 CalculatePressureForce(int i)
{
    float2 totalForce = 0.;

    float2 pos = predictedPositions[i];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if (i != otherParticleIndex)
                    {
                        totalForce +=
                            //masses[otherParticleIndex] * too many buffers..
                            (DensityToPressure(densities[i]) + DensityToPressure(densities[otherParticleIndex])) * 0.5f *
                            (-SmoothingKernelPow2Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                            / densities[i];
                        totalForce +=
                            //masses[otherParticleIndex] *
                            (NearDensityToPressure(nearDensities[i]) + NearDensityToPressure(nearDensities[otherParticleIndex])) * 0.5f *
                            (-SmoothingKernelPow3Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                            / densities[i];
                    }

                    currIndex++;
                }
            }
        }
    }

    return totalForce;
}

// Applies force to make velocity more similar to close particles
float2 CalculateViscosityForce(int i)
{
    float2 pos = predictedPositions[i];
    float2 vel = velocities[i];

    float2 totalForce = 0.;
    
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if (i != otherParticleIndex)
                    {
                        totalForce +=
                            //masses[otherParticleIndex] *
                            (velocities[otherParticleIndex] - vel) *
                            SmoothingKernelSmoothTop(SmoothingRadius, length(predictedPositions[otherParticleIndex] - pos));
                    }

                    currIndex++;
                }
            }
        }
    }
    return totalForce * ViscosityStrength;
}

float2 CalculateMouseForce(int particleIndex)
{
    float2 toParticle = predictedPositions[particleIndex] - MousePosition;//GameManager.Ins.inputManager.WorldMousePosition;

    float dist = length(toParticle);
    float2 dir = normalize(toParticle);

    if (MouseForceSign == 0. || dist >= MouseForceRadius) return 0.;
    float2 force = MouseForceStrength * MouseForceSign * dir; //* SmoothingKernelSmoothTop(MouseForceRadius, length(toParticle));
    return force;
}

// https://matthias-research.github.io/pages/publications/sca03.pdf 3.3
float2 EvaluateExistenceGradient(float2 pos) {
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    float2 totalGrad = 0.;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    totalGrad +=
                        //masses[otherParticleIndex] * too many buffers..
                        (SmoothingKernelPow2Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                        / densities[otherParticleIndex];

                    currIndex++;
                }
            }
        }
    }

    return totalGrad;
}

float EvaluateExistenceGradientDivergence(float2 pos) {
    // Using 4 samples of EvaluateExistenceGradient (will be 8 for 3D if wanna be accurate, or could approx with 4)
    // Curvature is Divergence of Unit Normal Vector or Divergence of Normal Vector div by Length of Normal Vec
    // Probably some way to use less samples
    
    float2 e = float2(0.1,0.);
    
    float dGradxdx = (EvaluateExistenceGradient(pos+e.xy).x - EvaluateExistenceGradient(pos-e.xy).x)/(2.0*e.x);
    float dGradydy = (EvaluateExistenceGradient(pos+e.yx).y - EvaluateExistenceGradient(pos-e.yx).y)/(2.0*e.x);

    float div = dGradxdx + dGradydy;
    return div;
}

float2 CalculateSurfaceTensionForce(int particleIndex) {
    float2 pos = positions[particleIndex];

    float2 grad = EvaluateExistenceGradient(pos);
    if(length(grad) <= 0.001) return 0.;

    float2 norm = normalize(grad);
    float div = EvaluateExistenceGradientDivergence(pos);

    return - SurfaceTensionMultiplier * norm * div;
}

[numthreads(64, 1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;
    float dt = DeltaTime;

    float2 pos = positions[i];
    float2 vel = velocities[i];

    // Densities being 0 (should never happen) causes positions to become NaN and particles to disappear
    float2 pressureAcceleration = CalculatePressureForce(i) / densities[i];
    float2 mouseAcceleration = CalculateMouseForce(i) / densities[i];
    float2 viscosityAcceleration = CalculateViscosityForce(i) / densities[i];
    float2 surfaceTensionAcceleration = 0.;//CalculateSurfaceTensionForce(i) / densities[i];
    float2 a = pressureAcceleration + mouseAcceleration + viscosityAcceleration + surfaceTensionAcceleration + Gravity;

    vel += a * dt;
    pos += vel * dt;

    // Collision
    float2 dist = (BoxDimensions * 0.5 - BoxThickness) - abs(pos) - ParticleRadius;
    if (dist.x <= 0.0)
    {
        pos.x = sign(pos.x) * (BoxDimensions.x * 0.5 - BoxThickness - ParticleRadius);
        vel.x *= -0.9;
    }
    else if (dist.y <= 0.0)
    {
        pos.y = sign(pos.y) * (BoxDimensions.y * 0.5 - BoxThickness - ParticleRadius);
        vel.y *= -0.9;
    }

    positions[i] = pos;
    colors[i] = lerp(float4(0.3, 0.4, 1.0, 1.0), float4(0.4, 0.8, 1.0, 1.0), smoothstep(0.0, 1.5, length(EvaluateExistenceGradient(positions[i]))));//length(velocities[i])));
    velocities[i] = vel;
}
