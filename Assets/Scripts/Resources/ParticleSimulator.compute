#pragma kernel CalculatePredictedPositions

#pragma kernel UpdateSpatialHashEntries
#pragma kernel ResetSpatialHashOffsets
#pragma kernel UpdateSpatialHashOffsets // Must be sorted at this point

#pragma kernel CalculateDensities
#pragma kernel UpdateParticles

//
RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> predictedPositions;
RWStructuredBuffer<float2> velocities;

RWStructuredBuffer<float> masses;

RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> nearDensities;

// Simulation Params
const int ParticleCount;
const float2 BoxDimensions;
const float BoxThickness;
const float2 Gravity;
const float ParticleRadius;
const float SmoothingRadius;
const float MouseForceRadius;
const float MouseForceStrength;
const float TargetDensity;
const float NearDensityPressureMultiplier;
const float PressureMultiplier;
// how to do gradients? seb lag idk what they did or i could just do gradient texture.. grad to tex?
const float ViscosityStrength;

//
const float DeltaTime;
const float SpatialLookupSize;
const float GridSize;

//
#include "./ParticleMath.hlsl"
#include "./SpatialHash.hlsl"

///
[numthreads(64, 1,1)]
void CalculatePredictedPositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    predictedPositions[i] = positions[i] + velocities[i] * (1.0/60.0);
}

[numthreads(64, 1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    float totalDensity = 0.0;
    float totalNearDensity = 0.0;

    float2 pos = predictedPositions[i];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    totalDensity += masses[i] * SmoothingKernelPow2(SmoothingRadius, length(predictedPositions[i] - pos));
                    totalNearDensity += masses[i] * SmoothingKernelPow3(SmoothingRadius, length(predictedPositions[i] - pos));

                    currIndex++;
                }
            }
        }
    }
}

[numthreads(64, 1,1)]
void UpdateSpatialHashEntries (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    int2 cell = posToCell(positions[i]);
    int key = getCellKey(cell);

    ParticleEntry e;
    e.particleIndex = i;
    e.key = key;

    particleCellKeyEntries[i] = e;
}

[numthreads(64, 1, 1)]
void ResetSpatialHashOffsets(uint3 id : SV_DispatchThreadID) {
    int i = id.x;
    if(i >= SpatialLookupSize) return;

    cellKeyToStartCoord[i] = -1;
}

[numthreads(64, 1,1)]
void UpdateSpatialHashOffsets (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // Check if the current index in the Particle Array is a start index
    if(i==0) {
        ParticleEntry e = particleCellKeyEntries[0];
        cellKeyToStartCoord[e.key] = i;
    } else {
        ParticleEntry eCurr = particleCellKeyEntries[i];
        ParticleEntry ePrev = particleCellKeyEntries[i-1];

        if(eCurr.key != ePrev.key) {
            cellKeyToStartCoord[eCurr.key] = i;
        }
    }
}

[numthreads(64, 1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;
    float dt = DeltaTime;

    float2 pos = positions[i];
    float2 vel = velocities[i];

    // Densities being 0 (should never happen) causes positions to become NaN and particles to disappear
    float2 pressureAcceleration = 0.0;//CalculatePressureForce(index) / densities[index];
    float2 mouseAcceleration = 0.0;//CalculateMouseForce(index) / densities[index];
    float2 viscosityAcceleration = 0.0;//CalculateViscosityForce(index) / densities[index];
    float2 a = Gravity;//pressureAcceleration + mouseAcceleration + viscosityAcceleration + Gravity;

    vel += a * dt;
    pos += vel * dt;

    // Collision
    float2 dist = (BoxDimensions * 0.5 - BoxThickness) - abs(pos) - ParticleRadius;
    if (dist.x <= 0.0)
    {
        pos.x = sign(pos.x) * (BoxDimensions.x * 0.5 - BoxThickness - ParticleRadius);
        vel.x *= -0.9;
    }
    else if (dist.y <= 0.0)
    {
        pos.y = sign(pos.y) * (BoxDimensions.y * 0.5 - BoxThickness - ParticleRadius);
        vel.y *= -0.9;
    }

    positions[i] = pos;
    velocities[i] = vel;
}
