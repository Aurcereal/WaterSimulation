#pragma multi_compile SCENE_COLLISION __
#pragma multi_compile BBX_COLLISION __
#pragma multi_compile OBSTACLE_COLLISION __
#pragma multi_compile CHECKERFLOOR_ENV EMPTY_ENV FOUNTAIN_ENV

#pragma multi_compile SIMULATE_FOAM __
#pragma multi_compile PRESSURE_FORCE __
#pragma multi_compile VISCOSITY_FORCE __
#pragma multi_compile STICK_FORCE __
#pragma multi_compile SPRING_FORCE __
// #define SIMULATE_FOAM
// #define PRESSURE_FORCE
// #define VISCOSITY_FORCE
// #define STICK_FORCE
// #define SPRING_FORCE

#define THREADGROUPSIZE 256
#define CUBETHREADGROUPSIZE 8

#pragma kernel CalculatePredictedPositions

#pragma kernel UpdateSpatialHashEntries
#pragma kernel UpdateSpatialHashOffsets // Must be sorted at this point

#pragma kernel CalculateDensities
#pragma kernel UpdateParticles

#pragma kernel CacheDensities

#pragma kernel UpdateFoamParticles
#pragma kernel MoveSurvivingFoamParticlesToUpdatingBuffer

//
RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> predictedPositions;
RWStructuredBuffer<float3> velocities;

RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> nearDensities;

RWStructuredBuffer<float4> colors;

// Simulation Params
const int ParticleCount;
const float3 Gravity;
const float ParticleRadius;
const float SmoothingRadius;
const float TargetDensity;
const float NearDensityPressureMultiplier;
const float PressureMultiplier;

const float ViscosityStrength;
const float SpringForceMultiplier;
const bool EnableParticleSprings;

const bool EnableStickForce;
const float MaxStickDistance;
const float StickForceMultiplier;

const float ForceFieldMultiplier;

const float4x4 ContainerInverseTransform;
const float4x4 ContainerTransform;
const float3 ContainerScale;

const float4x4 ObstacleInverseTransform;
const float3 ObstacleScale;
const bool ObstacleType;

RWTexture3D<float> DensityTexture;
float3 DensityTextureSize;

//
const float DeltaTime;

//
const float SqrSmoothingRadius;
const float InvSmoothingRadius;

//
const float FoamScaleMultiplier;

const float TrappedAirPotentialRemapLow;
const float TrappedAirPotentialRemapHigh;

const float TrappedAirMultiplier;

const float KineticPotentialRemapLow;
const float KineticPotentialRemapHigh;

const float HighestSprayDensity;
const float LowestBubbleDensity;

const float BubbleGravityMultiplier;
const float BubbleFluidConformingMultiplier;

const float SprayAirDragMultiplier;

const float TimeSinceStart;

const bool SpawnFoam;

// Debug Drawing
const float ParticleLowColorSpeed;
const float ParticleHighColorSpeed;
const float4 ParticleLowSpeedColor;
const float4 ParticleHighSpeedColor;

//
#include "./MathHelper.hlsl"
#include "./ParticleMath3D.hlsl"
#include "./SpatialHash3D.hlsl"
#include "./SDFMath3D.hlsl"

///
[numthreads(THREADGROUPSIZE, 1,1)]
void CalculatePredictedPositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    predictedPositions[i] = positions[i] + velocities[i] * (1.0/60.0);
}

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateSpatialHashEntries (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    int3 cell = posToCell(predictedPositions[i]);
    int key = getCellKey(cell);

    ParticleEntry e;
    e.particleIndex = i;
    e.key = key;

    particleCellKeyEntries[i] = e;
}

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateSpatialHashOffsets (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // Check if the current index in the Particle Array is a start index
    if(i==0) { // ODOT: i == 0 check causing bad performance?
        ParticleEntry e = particleCellKeyEntries[0];
        cellKeyToStartCoord[e.key] = i;
    } else {
        ParticleEntry eCurr = particleCellKeyEntries[i];
        ParticleEntry ePrev = particleCellKeyEntries[i-1];

        if(eCurr.key != ePrev.key) {
            cellKeyToStartCoord[eCurr.key] = i;
        }
    }
}

[numthreads(THREADGROUPSIZE, 1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    float totalDensity = 0.0;
    float totalNearDensity = 0.0;

    float3 pos = predictedPositions[i];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    float3 diff; float sqrDist;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        diff = predictedPositions[particleIndex] - pos;
                        sqrDist = dot(diff, diff);
                        if(sqrDist <= SqrSmoothingRadius) {
                            totalDensity += /*masses[particleIndex] **/ SmoothingKernelPow2Unsafe(sqrt(sqrDist));
                            totalNearDensity += /*masses[particleIndex] **/ SmoothingKernelPow3Unsafe(sqrt(sqrDist));
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    densities[i] = totalDensity;
    nearDensities[i] = totalNearDensity;
}

inline float DensityToPressure(float density)
{
    // TargetDensity kind of offsets pressure to determine what happens with empty space: 
    // if the result is high, our gradient will go from empty to wherever this is, 
    // if our result is low, our gradient will go from wherever this is to empty
    return PressureMultiplier * (density - TargetDensity);
}

inline float NearDensityToPressure(float nearDensity)
{
    // It's always a repelling force we 'want' the near density to be 0
    return NearDensityPressureMultiplier * nearDensity;
}

// Pressure force is -PressureGradient since we'll flow from high pressure to low pressure
float3 CalculatePressureForceAndAirPotential(int i, out float airPotential)
{
    float3 totalForce = 0.;

    float3 pos = predictedPositions[i];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;

    float scaledVelocityDiff = 0.;

    float3 vel = velocities[i];
    float dens = densities[i];

    /// TODO: Make this unsafe with a sqrdist check to not do if unnecessary and more optimal math fewer sqrt calculations
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if (i != otherParticleIndex)
                        {
                            float3 otherPos = predictedPositions[otherParticleIndex];
                            float3 diff = otherPos - pos;
                            float sqrDist = dot(diff, diff);
                            if(sqrDist <= SqrSmoothingRadius) {
                                float dist = sqrt(sqrDist);
                                float3 posDiffNormalize = diff / dist;

                                #ifdef PRESSURE_FORCE
                                totalForce +=
                                    (DensityToPressure(densities[i]) + DensityToPressure(densities[otherParticleIndex])) * 0.5f *
                                    (-SmoothingKernelPow2Gradient(SmoothingRadius, otherPos - pos))
                                    / dens;
                                totalForce +=
                                    (NearDensityToPressure(nearDensities[i]) + NearDensityToPressure(nearDensities[otherParticleIndex])) * 0.5f *
                                    (-SmoothingKernelPow3Gradient(SmoothingRadius, otherPos - pos))
                                    / dens;
                                #endif

                                // For WhiteWater (Spray, Foam, Bubbles) - https://cg.informatik.uni-freiburg.de/publications/2012_CGI_sprayFoamBubbles.pdf
                                #ifdef SIMULATE_FOAM
                                float3 velDiff = velocities[otherParticleIndex] - vel;
                                float velDiffLength = length(velDiff);
                                float3 velDiffNormalize = velDiff / velDiffLength;
                                scaledVelocityDiff += velDiffLength * (1. - dot(velDiffNormalize, posDiffNormalize)) * max(0., 1. - dist/SmoothingRadius);
                                #endif

                                // Spring Force (turn to compile keyword)
                                #ifdef SPRING_FORCE
                                float restLen = SmoothingRadius*.5;

                                float forceMult = SpringForceMultiplier * (1. - dist*InvSmoothingRadius) * (restLen - dist);
                                totalForce += forceMult * (-posDiffNormalize);
                                #endif
                            }
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    #ifdef SIMULATE_FOAM
    airPotential = clamp((scaledVelocityDiff - TrappedAirPotentialRemapLow) / (TrappedAirPotentialRemapHigh - TrappedAirPotentialRemapLow), 0., 1.);
    #else
    airPotential = 0.;
    #endif

    return totalForce;
}

// Applies force to make velocity more similar to close particles
float3 CalculateViscosityForce(int i)
{
    float3 pos = predictedPositions[i];
    float3 vel = velocities[i];

    float3 totalForce = 0.;
    
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if (i != otherParticleIndex)
                        {
                            float sqrDist = dot(predictedPositions[otherParticleIndex] - pos, predictedPositions[otherParticleIndex] - pos);
                            if(sqrDist <= SqrSmoothingRadius) {
                                totalForce +=
                                    //masses[otherParticleIndex] *
                                    (velocities[otherParticleIndex] - vel) *
                                    SmoothingKernelSmoothTopUnsafe(sqrt(sqrDist));
                            }
                        }

                        currIndex++;
                    }
                }
            }
        }
    }
    return totalForce * ViscosityStrength;
}

float3 CalculateStickinessForce(int particleIndex) {
    float3 pos = predictedPositions[particleIndex];
    float d = sdScene(pos);

    float forceMag = max(0., StickForceMultiplier * d * (1.0 - d/MaxStickDistance));
    float3 norm = normal(pos);
    return -norm * forceMag;
}

float3 sampleForceField(float3 p);

#ifdef BBX_COLLISION
#include "../../../Env/BoundingBoxEnvPhysics.hlsl"
#endif
#ifdef OBSTACLE_COLLISION
#include "../../../Env/ObstacleEnvPhysics.hlsl"
#endif

#ifdef CHECKERFLOOR_ENV
#include "../../../Env/CheckerFloorEnvPhysics.hlsl"
#elif defined(EMPTY_ENV)
#include "../../../Env/EmptyEnvPhysics.hlsl"
#elif defined(FOUNTAIN_ENV)
#include "../../../Env/FountainEnvPhysics.hlsl"
#endif

float sdScene(float3 p) {
    #ifdef SCENE_COLLISION
    float sd = sdEnv(p);
    #else
    float sd = 100000.0;
    #endif

    #ifdef BBX_COLLISION
    sd = min(sd, sdBoundingBox(p));
    #endif

    #ifdef OBSTACLE_COLLISION
    sd = min(sd, sdObstacle(p));
    #endif

    return sd;
}

/// Just returns first velocity of nearby particle it finds (since particles could be sparse)
float3 EstimateVelocity(float3 pos) {
    float3 avgVel = 0.;

    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(positions[particleIndex] - pos, positions[particleIndex] - pos);

                        if(sqrDist <= SmoothingRadius*SmoothingRadius) { 
                            return velocities[particleIndex];
                            //avgVel += velocities[particleIndex] * SmoothingKernelPow2Unsafe(sqrt(sqrDist)) / densities[particleIndex];
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return avgVel;
}

#include "./FoamParticles.hlsl"

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;
    float dt = DeltaTime;

    float3 pos = positions[i];
    float3 vel = velocities[i];
    float dens = densities[i];

    float airPotential = 0.;

    // Densities being 0 (should never happen) causes positions to become NaN and particles to disappear
    #if defined PRESSURE_FORCE || defined SPRING_FORCE || defined SIMULATE_FOAM
    float3 pressureAcceleration = CalculatePressureForceAndAirPotential(i, airPotential) / dens;
    #else
    float3 pressureAcceleration = 0.;
    #endif

    #ifdef VISCOSITY_FORCE
    float3 viscosityAcceleration = CalculateViscosityForce(i) / dens;
    #else
    float3 viscosityAcceleration = 0.;
    #endif

    #ifdef STICK_FORCE
    float3 stickinessAcceleration = CalculateStickinessForce(i) / dens;
    #else
    float3 stickinessAcceleration = 0.;
    #endif

    #ifdef FORCE_FIELD // TODO: make disabeable
    float3 forceFieldAcceleration = ForceFieldMultiplier * sampleForceField(pos) / dens;
    #else
    float3 forceFieldAcceleration = 0.;
    #endif

    float3 a = pressureAcceleration + viscosityAcceleration + stickinessAcceleration + forceFieldAcceleration + Gravity;

    // Handle Spawning Foam
    #ifdef SIMULATE_FOAM
    if(i == 0) 
        foamParticleCounts[1] = 0; // Need to 'clear' survivor buffer

    float kineticEnergy = 0.5 * dot(vel, vel);
    float kineticPotential = clamp((kineticEnergy - KineticPotentialRemapLow) / (KineticPotentialRemapHigh - KineticPotentialRemapLow), 0., 1.);
    float spawnRate = kineticPotential * (TrappedAirMultiplier * airPotential); // ODOT: Maybe add wave crest
    float numSpawn = dt * spawnRate * spawnRate;
    float spd = length(vel);
    float numSpawnMultiplier = clamp(TimeSinceStart - 2.5, 0., 1.);
    if(spd > 0.) SpawnFoamParticlesInCylinder(0., pos, vel, numSpawn * numSpawnMultiplier, SmoothingRadius, spd * dt, vel/spd);
    #endif

    vel += a * dt;
    pos += vel * dt;

    // Collision
    float dScene = sdScene(pos) - ParticleRadius; // We need Particle Radius for correct raymarching keeping all density inside bounds?
    if(dScene < 0.) {
        float3 norm = normal(pos);
        vel -= 2. * norm * dot(norm, vel);
        pos -= norm * dScene;
    }

    positions[i] = pos;
    colors[i] = lerp(ParticleLowSpeedColor, ParticleHighSpeedColor, clamp((length(vel) - ParticleLowColorSpeed)/(ParticleHighColorSpeed - ParticleLowColorSpeed), 0., 1.)); // TODO: Debug draw only
    velocities[i] = vel;
}

// Doesn't use predicted positions
float CalculateDensity(float3 pos) {
    float totalDensity = 0.0;

    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(positions[particleIndex] - pos, positions[particleIndex] - pos);

                        if(sqrDist <= SmoothingRadius*SmoothingRadius) {
                            totalDensity += /*masses[particleIndex] * */SmoothingKernelPow2Unsafe(sqrt(sqrDist));
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return totalDensity;
}

// temp
float CalculateDensity(float3 pos, float h) {
    float totalDensity = 0.0;

    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(positions[particleIndex] - pos, positions[particleIndex] - pos);

                        if(sqrDist <= h*h) {
                            totalDensity += /*masses[particleIndex] * */SmoothingKernelPow2(h, sqrt(sqrDist));
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return totalDensity;
}

[numthreads(CUBETHREADGROUPSIZE, CUBETHREADGROUPSIZE, CUBETHREADGROUPSIZE)]
void CacheDensities(uint3 id : SV_DispatchThreadID) {
    float3 uv = (1.0*id)/(1.0*(DensityTextureSize-1.0));
    if(max(max(uv.x, uv.y), uv.z) > 1.) return;

    float3 untransformedP = uv-0.5;
    float3 worldPos = mul(ContainerTransform, float4(untransformedP, 1.0)).xyz;

    DensityTexture[id] = CalculateDensity(worldPos);
}

// TODO: Rename cuz it's not just foam particles it's white particles comprised of spray, foam, bubbles
[numthreads(THREADGROUPSIZE, 1, 1)]
void UpdateFoamParticles(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if(i >= foamParticleCounts[0]) return;

    float3 pos = updatingFoamParticles[i].position;
    float dens = CalculateDensity(pos);

    // What type of particle is it this frame? 
    // ODOT: To optimize could change classifications once every few frames or only do some particles per frame
    if(dens <= HighestSprayDensity) {
        UpdateSprayParticle(i, DeltaTime);
    } else if(dens >= LowestBubbleDensity) {
        UpdateBubbleParticle(i, DeltaTime);
    } else {
        UpdateFoamParticle(i, DeltaTime);
    }
}

[numthreads(THREADGROUPSIZE, 1, 1)]
void MoveSurvivingFoamParticlesToUpdatingBuffer(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if(i >= foamParticleCounts[1]) return;

    if(i == 0)
        foamParticleCounts[0] = foamParticleCounts[1];

    updatingFoamParticles[i] = survivingFoamParticles[i];
}