#pragma kernel CalculatePredictedPositions

#pragma kernel UpdateSpatialHashEntries
#pragma kernel ResetSpatialHashOffsets
#pragma kernel UpdateSpatialHashOffsets // Must be sorted at this point

#pragma kernel UpdateSpringLengths
#pragma kernel CalculateDensities
#pragma kernel UpdateParticles

//
RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> predictedPositions;
RWStructuredBuffer<float2> velocities;

RWStructuredBuffer<float> masses;

RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> nearDensities;

RWStructuredBuffer<float> springRestLengths;

RWStructuredBuffer<float4> colors;

// Simulation Params
const int ParticleCount;
const float2 Gravity;
const float ParticleRadius;
const float SmoothingRadius;
const float MouseForceRadius;
const float MouseForceStrength;
const float TargetDensity;
const float NearDensityPressureMultiplier;
const float PressureMultiplier;
// how to do color gradients? seb lag idk what they did or i could just do gradient texture.. grad to tex?
const float ViscosityStrength;
const float SurfaceTensionMultiplier;
const float SpringForceMultiplier;
const float Plasticity;
const float SpringYieldRatio;
const bool EnableParticleSprings;
const float MaxStickDistance;
const float StickForceMultiplier;

const float2 BoxDimensions;
const float BoxThickness;

// In 3D maybe have a scale vec, but then a rot tra matrix
const float2 ObstacleDimensions;
const float2 ObstaclePosition;
const float ObstacleRotation;
const bool IsObstacleBox;

//
const float GridSize;
const int SpatialLookupSize;

//
const float DeltaTime;

//
const float MouseForceSign;
const float2 MousePosition;

//
#include "./ParticleMath.hlsl"
#include "./SpatialHash.hlsl"
#include "./MathHelper.hlsl"
#include "./SDFMath2D.hlsl"

///
[numthreads(64, 1,1)]
void CalculatePredictedPositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    predictedPositions[i] = positions[i] + velocities[i] * (1.0/60.0);
}

[numthreads(64, 1,1)]
void UpdateSpatialHashEntries (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    int2 cell = posToCell(predictedPositions[i]);
    int key = getCellKey(cell);

    ParticleEntry e;
    e.particleIndex = i;
    e.key = key;

    particleCellKeyEntries[i] = e;
}

[numthreads(64, 1, 1)]
void ResetSpatialHashOffsets(uint3 id : SV_DispatchThreadID) {
    int i = id.x;
    if(i >= SpatialLookupSize) return;

    cellKeyToStartCoord[i] = -1;
}

[numthreads(64, 1,1)]
void UpdateSpatialHashOffsets (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // Check if the current index in the Particle Array is a start index
    if(i==0) {
        ParticleEntry e = particleCellKeyEntries[0];
        cellKeyToStartCoord[e.key] = i;
    } else {
        ParticleEntry eCurr = particleCellKeyEntries[i];
        ParticleEntry ePrev = particleCellKeyEntries[i-1];

        if(eCurr.key != ePrev.key) {
            cellKeyToStartCoord[eCurr.key] = i;
        }
    }
}

[numthreads(64, 1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    float totalDensity = 0.0;
    float totalNearDensity = 0.0;

    float2 pos = predictedPositions[i];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int particleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    particleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    totalDensity += masses[particleIndex] * SmoothingKernelPow2(SmoothingRadius, length(predictedPositions[particleIndex] - pos));
                    totalNearDensity += masses[particleIndex] * SmoothingKernelPow3(SmoothingRadius, length(predictedPositions[particleIndex] - pos));

                    currIndex++;
                }
            }
        }
    }

    densities[i] = totalDensity;
    nearDensities[i] = totalNearDensity;
}

void UpdateSprings(int particleIndex, float dt);

[numthreads(64, 1,1)]
void UpdateSpringLengths (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // also update springs here lol
    UpdateSprings(i, DeltaTime);
}

float DensityToPressure(float density)
{
    // TargetDensity kind of offsets pressure to determine what happens with empty space: 
    // if the result is high, our gradient will go from empty to wherever this is, 
    // if our result is low, our gradient will go from wherever this is to empty
    return PressureMultiplier * (density - TargetDensity);
}

float NearDensityToPressure(float nearDensity)
{
    // It's always a repelling force we 'want' the near density to be 0
    return NearDensityPressureMultiplier * nearDensity;
}

// Pressure force is -PressureGradient since we'll flow from high pressure to low pressure
float2 CalculatePressureForce(int i)
{
    float2 totalForce = 0.;

    float2 pos = predictedPositions[i];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if (i != otherParticleIndex)
                    {
                        totalForce +=
                            masses[otherParticleIndex] *
                            (DensityToPressure(densities[i]) + DensityToPressure(densities[otherParticleIndex])) * 0.5f *
                            (-SmoothingKernelPow2Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                            / densities[i];
                        totalForce +=
                            masses[otherParticleIndex] *
                            (NearDensityToPressure(nearDensities[i]) + NearDensityToPressure(nearDensities[otherParticleIndex])) * 0.5f *
                            (-SmoothingKernelPow3Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                            / densities[i];
                    }

                    currIndex++;
                }
            }
        }
    }

    return totalForce;
}

// Applies force to make velocity more similar to close particles
float2 CalculateViscosityForce(int i)
{
    float2 pos = predictedPositions[i];
    float2 vel = velocities[i];

    float2 totalForce = 0.;
    
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if (i != otherParticleIndex)
                    {
                        totalForce +=
                            masses[otherParticleIndex] *
                            (velocities[otherParticleIndex] - vel) *
                            SmoothingKernelSmoothTop(SmoothingRadius, length(predictedPositions[otherParticleIndex] - pos));
                    }

                    currIndex++;
                }
            }
        }
    }
    return totalForce * ViscosityStrength;
}

float2 CalculateMouseForce(int particleIndex)
{
    float2 toParticle = predictedPositions[particleIndex] - MousePosition;//GameManager.Ins.inputManager.WorldMousePosition;

    float dist = length(toParticle);
    float2 dir = normalize(toParticle);

    if (MouseForceSign == 0. || dist >= MouseForceRadius) return 0.;
    float2 force = MouseForceStrength * MouseForceSign * dir; //* SmoothingKernelSmoothTop(MouseForceRadius, length(toParticle));
    return force;
}

// https://matthias-research.github.io/pages/publications/sca03.pdf 3.3
float2 EvaluateExistenceGradient(float2 pos, int particleIndex) {
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    float2 totalGrad = 0.;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if(otherParticleIndex != particleIndex) {

                        totalGrad +=
                            masses[otherParticleIndex] * 
                            (SmoothingKernelPow2Gradient(SmoothingRadius, predictedPositions[otherParticleIndex] - pos))
                            / densities[otherParticleIndex];

                    }

                    currIndex++;
                }
            }
        }
    }

    return totalGrad;
}

float EvaluateExistenceGradientDivergence(float2 pos, int particleIndex) {
    // Using 4 samples of EvaluateExistenceGradient (will be 8 for 3D if wanna be accurate, or could approx with 4)
    // Curvature is Divergence of Unit Normal Vector or Divergence of Normal Vector div by Length of Normal Vec
    // Probably some way to use less samples
    
    float2 e = float2(0.1,0.);
    
    float dGradxdx = (EvaluateExistenceGradient(pos+e.xy, particleIndex).x - EvaluateExistenceGradient(pos-e.xy, particleIndex).x)/(2.0*e.x);
    float dGradydy = (EvaluateExistenceGradient(pos+e.yx, particleIndex).y - EvaluateExistenceGradient(pos-e.yx, particleIndex).y)/(2.0*e.x);

    float div = dGradxdx + dGradydy;
    return div;
}

float2 CalculateSurfaceTensionForce(int particleIndex) {
    float2 pos = positions[particleIndex];

    float2 grad = EvaluateExistenceGradient(pos, particleIndex);
    if(length(grad) <= 0.001) return 0.;

    float2 norm = normalize(grad);
    float div = EvaluateExistenceGradientDivergence(pos, particleIndex);

    return SurfaceTensionMultiplier * norm * div;
}

float getSpringLength(int i1, int i2) {
    return springRestLengths[i1 * ParticleCount + i2];
}

void setSpringLength(int i1, int i2, float val) {
    springRestLengths[i1 * ParticleCount + i2] = val;
}

void UpdateSprings(int particleIndex, float dt) {

    float2 pos = predictedPositions[particleIndex];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    // could cut down spring adjustments by half since order doesn't matter

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if(otherParticleIndex != particleIndex) {
                        float r = length(predictedPositions[otherParticleIndex]-pos);
                        if(r <= SmoothingRadius) {
                            // Add spring if there's none already
                            if(getSpringLength(particleIndex, otherParticleIndex) < 0.)
                                setSpringLength(particleIndex, otherParticleIndex, SmoothingRadius*0.5);

                            float restLen = getSpringLength(particleIndex, otherParticleIndex);

                            float tolerableDeformation = SpringYieldRatio * restLen;

                            if(r > restLen + tolerableDeformation)
                                restLen += dt * Plasticity * (r - (restLen+tolerableDeformation));
                            else if(r < restLen - tolerableDeformation)
                                restLen += dt * Plasticity * (r - (restLen-tolerableDeformation));

                            setSpringLength(particleIndex, otherParticleIndex, restLen);
                        } else {
                            // Remove spring, too far
                            setSpringLength(particleIndex, otherParticleIndex, -1.0);
                        }
                    }

                    currIndex++;
                }
            }
        }
    }
}

float2 CalculateSpringForce(int particleIndex) {

    float2 pos = predictedPositions[particleIndex];
    int2 centerCellPos = posToCell(pos);
    int2 currCell;
    int otherParticleIndex;

    float2 totalForce = 0.;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            currCell = centerCellPos + int2(x, y);

            int key = getCellKey(currCell);
            int currIndex = getStartIndex(key);

            if(currIndex != -1) {
                while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                    otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                    if(otherParticleIndex != particleIndex) {
                        float r = length(predictedPositions[otherParticleIndex]-pos);
                        if(r <= SmoothingRadius) {
                            float restLen = getSpringLength(particleIndex, otherParticleIndex);

                            float forceMult = SpringForceMultiplier * (1. - r/SmoothingRadius) * (restLen - r);
                            totalForce += forceMult * normalize(pos - predictedPositions[otherParticleIndex]);
                        }
                    }

                    currIndex++;
                }
            }
        }
    }

    return totalForce;
}

float2 CalculateStickinessForce(int particleIndex) {
    float2 pos = predictedPositions[particleIndex];
    float d = sdScene(pos);

    float forceMag = max(0., StickForceMultiplier * d * (1.0 - d/MaxStickDistance));
    float2 norm = normal(pos);
    return -norm * forceMag;
}

float sdScene(float2 p) {
    float dBox = -sdBox(p, BoxDimensions-BoxThickness*2.0);
    float dObstacle = IsObstacleBox ? 
        sdBox(rot(p - ObstaclePosition, ObstacleRotation), ObstacleDimensions) :
        sdCircle(p - ObstaclePosition, ObstacleDimensions.x);
    return min(dBox, dObstacle);
}

[numthreads(64, 1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;
    float dt = DeltaTime;

    float2 pos = positions[i];
    float2 vel = velocities[i];

    // Densities being 0 (should never happen) causes positions to become NaN and particles to disappear
    float2 pressureAcceleration = CalculatePressureForce(i) / densities[i];
    float2 mouseAcceleration = CalculateMouseForce(i) / densities[i];
    float2 viscosityAcceleration = CalculateViscosityForce(i) / densities[i];
    float2 surfaceTensionAcceleration = SurfaceTensionMultiplier > 0.0001 ? CalculateSurfaceTensionForce(i) / densities[i] : 0.;
    float2 springAcceleration = EnableParticleSprings ? CalculateSpringForce(i) / densities[i] : 0.;
    float2 stickinessAcceleration = CalculateStickinessForce(i) / densities[i];
    float2 a = pressureAcceleration + mouseAcceleration + viscosityAcceleration + surfaceTensionAcceleration + springAcceleration + stickinessAcceleration + Gravity;

    vel += a * dt;
    pos += vel * dt;

    // Collision
    float dScene = sdScene(pos) - ParticleRadius;
    if(dScene < 0.) {
        float2 norm = normal(pos);
        vel -= 2. * norm * dot(norm, vel);
        pos -= norm * dScene;
    }

    positions[i] = pos;
    colors[i] = lerp(float4(0.3, 0.4, 1.0, 1.0), float4(0.4, 0.8, 1.0, 1.0), smoothstep(0., 7.5, length(velocities[i])));//smoothstep(0.5, 1.5, length(EvaluateExistenceGradient(positions[i], -1))));//length(velocities[i])));
    velocities[i] = vel;
}
