#define THREADGROUPSIZE 256
#define CUBETHREADGROUPSIZE 8

#pragma kernel CalculatePredictedPositions

#pragma kernel UpdateSpatialHashEntries
#pragma kernel ResetSpatialHashOffsets
#pragma kernel UpdateSpatialHashOffsets // Must be sorted at this point

#pragma kernel UpdateSpringLengths
#pragma kernel CalculateDensities
#pragma kernel UpdateParticles

#pragma kernel CacheDensities

#pragma kernel UpdateFoamParticles
#pragma kernel MoveSurvivingFoamParticlesToUpdatingBuffer

//
RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> predictedPositions;
RWStructuredBuffer<float3> velocities;

RWStructuredBuffer<float> masses;
RWStructuredBuffer<float> densities;
RWStructuredBuffer<float> nearDensities;

RWStructuredBuffer<float> springRestLengths;

RWStructuredBuffer<float4> colors;

// Simulation Params
const int ParticleCount;
const float3 Gravity;
const float ParticleRadius;
const float SmoothingRadius;
const float MouseForceRadius;
const float MouseForceStrength;
const float TargetDensity;
const float NearDensityPressureMultiplier;
const float PressureMultiplier;

const float ViscosityStrength;
const float SurfaceTensionMultiplier;
const float SpringForceMultiplier;
const float Plasticity;
const float SpringYieldRatio;
const bool EnableParticleSprings;

const bool EnableStickForce;
const float MaxStickDistance;
const float StickForceMultiplier;

const float4x4 ContainerInverseTransform;
const float4x4 ContainerTransform;
const float3 ContainerScale;

const float4x4 ObstacleInverseTransform;
const float3 ObstacleScale;
const bool ObstacleType;
const bool ObstacleSimInteraction;

RWTexture3D<float> DensityTexture;
float3 DensityTextureSize;

//
const float DeltaTime;

//
const float SqrSmoothingRadius;
const float InvSmoothingRadius;

//
const float MouseForceSign;
const float2 MousePosition;

//
const float TrappedAirPotentialRemapLow;
const float TrappedAirPotentialRemapHigh;

const float TrappedAirMultiplier;

const float KineticPotentialRemapLow;
const float KineticPotentialRemapHigh;

const float HighestSprayDensity;
const float LowestBubbleDensity;

const float BubbleGravityMultiplier;
const float BubbleFluidConformingMultiplier;

const float SprayAirDragMultiplier;

const float TimeSinceStart;

//
#include "./MathHelper.hlsl"
#include "./ParticleMath3D.hlsl"
#include "./SpatialHash3D.hlsl"
#include "./SDFMath3D.hlsl"

///
[numthreads(THREADGROUPSIZE, 1,1)]
void CalculatePredictedPositions (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    predictedPositions[i] = positions[i] + velocities[i] * (1.0/60.0);
}

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateSpatialHashEntries (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    int3 cell = posToCell(predictedPositions[i]);
    int key = getCellKey(cell);

    ParticleEntry e;
    e.particleIndex = i;
    e.key = key;

    particleCellKeyEntries[i] = e;
}

[numthreads(THREADGROUPSIZE, 1, 1)]
void ResetSpatialHashOffsets(uint3 id : SV_DispatchThreadID) {
    int i = id.x;
    if(i >= SpatialLookupSize) return;

    cellKeyToStartCoord[i] = -1;
}

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateSpatialHashOffsets (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    // Check if the current index in the Particle Array is a start index
    if(i==0) {
        ParticleEntry e = particleCellKeyEntries[0];
        cellKeyToStartCoord[e.key] = i;
    } else {
        ParticleEntry eCurr = particleCellKeyEntries[i];
        ParticleEntry ePrev = particleCellKeyEntries[i-1];

        if(eCurr.key != ePrev.key) {
            cellKeyToStartCoord[eCurr.key] = i;
        }
    }
}

[numthreads(THREADGROUPSIZE, 1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    float totalDensity = 0.0;
    float totalNearDensity = 0.0;

    float3 pos = predictedPositions[i];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(predictedPositions[particleIndex] - pos, predictedPositions[particleIndex] - pos);
                        if(sqrDist <= SmoothingRadius*SmoothingRadius) {
                            totalDensity += /*masses[particleIndex] **/ SmoothingKernelPow2Unsafe(sqrt(sqrDist));
                            totalNearDensity += /*masses[particleIndex] **/ SmoothingKernelPow3Unsafe(sqrt(sqrDist));
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    densities[i] = totalDensity;
    nearDensities[i] = totalNearDensity;
}

void UpdateSprings(int particleIndex, float dt);

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateSpringLengths (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;

    UpdateSprings(i, DeltaTime);
}

float DensityToPressure(float density)
{
    // TargetDensity kind of offsets pressure to determine what happens with empty space: 
    // if the result is high, our gradient will go from empty to wherever this is, 
    // if our result is low, our gradient will go from wherever this is to empty
    return PressureMultiplier * (density - TargetDensity);
}

float NearDensityToPressure(float nearDensity)
{
    // It's always a repelling force we 'want' the near density to be 0
    return NearDensityPressureMultiplier * nearDensity;
}

// Pressure force is -PressureGradient since we'll flow from high pressure to low pressure
float3 CalculatePressureForceAndAirPotential(int i, out float airPotential)
{
    float3 totalForce = 0.;

    float3 pos = predictedPositions[i];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;

    float scaledVelocityDiff = 0.;

    float3 vel = velocities[i];
    float dens = densities[i];

    /// TODO: make this unsafe with a sqrdist check to not do if unnecessary and more optimal math fewer sqrt calculations
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if (i != otherParticleIndex)
                        {
                            float3 otherPos = predictedPositions[otherParticleIndex];
                            float dist = length(otherPos - pos);

                            totalForce +=
                                (DensityToPressure(densities[i]) + DensityToPressure(densities[otherParticleIndex])) * 0.5f *
                                (-SmoothingKernelPow2Gradient(SmoothingRadius, otherPos - pos))
                                / dens;
                            totalForce +=
                                (NearDensityToPressure(nearDensities[i]) + NearDensityToPressure(nearDensities[otherParticleIndex])) * 0.5f *
                                (-SmoothingKernelPow3Gradient(SmoothingRadius, otherPos - pos))
                                / dens;

                            // For WhiteWater (Spray, Foam, Bubbles) - https://cg.informatik.uni-freiburg.de/publications/2012_CGI_sprayFoamBubbles.pdf
                            float3 velDiff = velocities[otherParticleIndex] - vel;
                            float velDiffLength = length(velDiff);
                            float3 velDiffNormalize = velDiff / velDiffLength;
                            float3 posDiffNormalize = (otherPos - pos) / dist;
                            scaledVelocityDiff += velDiffLength * (1. - dot(velDiffNormalize, posDiffNormalize)) * max(0., 1. - dist/SmoothingRadius);
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    airPotential = clamp((scaledVelocityDiff - TrappedAirPotentialRemapLow) / (TrappedAirPotentialRemapHigh - TrappedAirPotentialRemapLow), 0., 1.);

    return totalForce;
}

// Applies force to make velocity more similar to close particles
float3 CalculateViscosityForce(int i)
{
    float3 pos = predictedPositions[i];
    float3 vel = velocities[i];

    float3 totalForce = 0.;
    
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;
    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if (i != otherParticleIndex)
                        {
                            float sqrDist = dot(predictedPositions[otherParticleIndex] - pos, predictedPositions[otherParticleIndex] - pos);
                            if(sqrDist <= SqrSmoothingRadius) {
                                totalForce +=
                                    //masses[otherParticleIndex] *
                                    (velocities[otherParticleIndex] - vel) *
                                    SmoothingKernelSmoothTopUnsafe(sqrt(sqrDist));
                            }
                        }

                        currIndex++;
                    }
                }
            }
        }
    }
    return totalForce * ViscosityStrength;
}

float getSpringLength(int i1, int i2) {
    return springRestLengths[i1 * ParticleCount + i2];
}

void setSpringLength(int i1, int i2, float val) {
    springRestLengths[i1 * ParticleCount + i2] = val;
}

// Optimize length
void UpdateSprings(int particleIndex, float dt) {

    float3 pos = predictedPositions[particleIndex];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;

    // could cut down spring adjustments by half since order doesn't matter
    // also the linked list method would be better ~ O(100n) where 100 is like neighbors insetad of O(n^2)

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if(otherParticleIndex != particleIndex) {
                            float r = length(predictedPositions[otherParticleIndex]-pos);
                            if(r <= SmoothingRadius) {
                                // Add spring if there's none already
                                if(getSpringLength(particleIndex, otherParticleIndex) < 0.)
                                    setSpringLength(particleIndex, otherParticleIndex, SmoothingRadius*0.5);

                                float restLen = getSpringLength(particleIndex, otherParticleIndex);

                                float tolerableDeformation = SpringYieldRatio * restLen;

                                if(r > restLen + tolerableDeformation)
                                    restLen += dt * Plasticity * (r - (restLen+tolerableDeformation));
                                else if(r < restLen - tolerableDeformation)
                                    restLen += dt * Plasticity * (r - (restLen-tolerableDeformation));

                                setSpringLength(particleIndex, otherParticleIndex, restLen);
                            } else {
                                // Remove spring, too far
                                setSpringLength(particleIndex, otherParticleIndex, -1.0);
                            }
                        }

                        currIndex++;
                    }
                }
            }
        }
    }
}

float3 CalculateSpringForce(int particleIndex) {

    float3 pos = predictedPositions[particleIndex];
    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int otherParticleIndex;

    float3 totalForce = 0.;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        otherParticleIndex = particleCellKeyEntries[currIndex].particleIndex;

                        if(otherParticleIndex != particleIndex) {
                            float sqrDist = dot(predictedPositions[otherParticleIndex]-pos, predictedPositions[otherParticleIndex]-pos);
                            if(sqrDist <= SqrSmoothingRadius) {
                                float r = sqrt(sqrDist);
                                float restLen = getSpringLength(particleIndex, otherParticleIndex);

                                float forceMult = SpringForceMultiplier * (1. - r*InvSmoothingRadius) * (restLen - r);
                                totalForce += forceMult * normalize(pos - predictedPositions[otherParticleIndex]);
                            }
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return totalForce;
}

float3 CalculateStickinessForce(int particleIndex) {
    float3 pos = predictedPositions[particleIndex];
    float d = sdScene(pos);

    float forceMag = max(0., StickForceMultiplier * d * (1.0 - d/MaxStickDistance));
    float3 norm = normal(pos);
    return -norm * forceMag;
}

float sdScene(float3 p) {
    float dBox = -sdBox(ContainerScale * mul(ContainerInverseTransform, float4(p, 1.)).xyz, ContainerScale);
    float dObstacle = !ObstacleSimInteraction ? 10000.0 : ObstacleType ? 
        sdBox(ObstacleScale * mul(ObstacleInverseTransform, float4(p, 1.)).xyz, ObstacleScale-1.5*SmoothingRadius) : 
        sdSphere(ObstacleScale * mul(ObstacleInverseTransform, float4(p, 1.)).xyz, ObstacleScale.x-1.5*SmoothingRadius);
    return min(dBox, dObstacle);
}

float3 EstimateVelocity(float3 pos) {
    float3 avgVel = 0.;

    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=0; x<=0; x++) {
        for(int y=0; y<=0; y++) {
            for(int z=0; z<=0; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(positions[particleIndex] - pos, positions[particleIndex] - pos);

                        if(sqrDist <= SmoothingRadius*SmoothingRadius) { return velocities[particleIndex]; // TEMP TODO: TAKE OUT
                            avgVel += velocities[particleIndex] * SmoothingKernelPow2Unsafe(sqrt(sqrDist)) / densities[particleIndex];
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return avgVel;
}

#include "./FoamParticles.hlsl"

[numthreads(THREADGROUPSIZE, 1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    int i = id.x;
    if(i >= ParticleCount) return;
    float dt = DeltaTime;

    float3 pos = positions[i];
    float3 vel = velocities[i];
    float dens = densities[i];

    float airPotential;

    // Densities being 0 (should never happen) causes positions to become NaN and particles to disappear
    float3 pressureAcceleration = CalculatePressureForceAndAirPotential(i, airPotential) / dens;
    float3 viscosityAcceleration = CalculateViscosityForce(i) / dens;
    float3 springAcceleration = EnableParticleSprings ? CalculateSpringForce(i) / dens : 0.;
    float3 stickinessAcceleration = EnableStickForce ? CalculateStickinessForce(i) / dens : 0.;
    float3 a = pressureAcceleration + viscosityAcceleration + stickinessAcceleration + springAcceleration + Gravity;

    // Handle Spawning WhiteWater
    if(i == 0) 
        foamParticleCounts[1] = 0; // Need to 'clear' survivor buffer

    float kineticEnergy = 0.5 * dot(vel, vel);
    float kineticPotential = clamp((kineticEnergy - KineticPotentialRemapLow) / (KineticPotentialRemapHigh - KineticPotentialRemapLow), 0., 1.);
    float numSpawn = dt * kineticPotential * (TrappedAirMultiplier * airPotential); // TODO: maybe add wave crest
    float spd = length(vel);
    float numSpawnMultiplier = clamp(TimeSinceStart - 2.5, 0., 1.);
    if(spd > 0.) SpawnFoamParticlesInCylinder(0., pos, vel, numSpawn * numSpawnMultiplier, SmoothingRadius, spd * dt, vel/spd);

    vel += a * dt;
    pos += vel * dt;

    // Collision
    float dScene = sdScene(pos) - ParticleRadius; // We need Particle Radius for correct raymarching keeping all density inside bounds?
    if(dScene < 0.) {
        float3 norm = normal(pos);
        vel -= 2. * norm * dot(norm, vel);
        pos -= norm * dScene;
    }

    positions[i] = pos;
    colors[i] = float4(hash31(pos) < frac(numSpawn) ? 0. : 1., 1., 0., 1.);//float4(kineticPotential * (TrappedAirMultiplier * airPotential), 1., 0.,1.);//colors[i] = lerp(float4(0.3, 0.4, 1.0, 1.0), float4(0.4, 0.8, 1.0, 1.0), smoothstep(0., 7.5, length(velocities[i])));//smoothstep(0.5, 1.5, length(EvaluateExistenceGradient(positions[i], -1))));//length(velocities[i])));
    velocities[i] = vel;
}

// Doesn't use predicted positions
float CalculateDensity(float3 pos) {
    float totalDensity = 0.0;

    int3 centerCellPos = posToCell(pos);
    int3 currCell;
    int particleIndex;

    for(int x=-1; x<=1; x++) {
        for(int y=-1; y<=1; y++) {
            for(int z=-1; z<=1; z++) {
                currCell = centerCellPos + int3(x, y, z);

                int key = getCellKey(currCell);
                int currIndex = getStartIndex(key);

                if(currIndex != -1) {
                    while(currIndex < ParticleCount && particleCellKeyEntries[currIndex].key == key) {

                        particleIndex = particleCellKeyEntries[currIndex].particleIndex;
                        
                        float sqrDist = dot(positions[particleIndex] - pos, positions[particleIndex] - pos);

                        if(sqrDist <= SmoothingRadius*SmoothingRadius) {
                            totalDensity += /*masses[particleIndex] * */SmoothingKernelPow2Unsafe(sqrt(sqrDist));
                        }

                        currIndex++;
                    }
                }
            }
        }
    }

    return totalDensity;
}

[numthreads(CUBETHREADGROUPSIZE, CUBETHREADGROUPSIZE, CUBETHREADGROUPSIZE)]
void CacheDensities(uint3 id : SV_DispatchThreadID) {
    float3 uv = (1.0*id)/(1.0*(DensityTextureSize-1.0));
    if(max(max(uv.x, uv.y), uv.z) > 1.) return;

    float3 untransformedP = uv-0.5;
    float3 worldPos = mul(ContainerTransform, float4(untransformedP, 1.0)).xyz;

    DensityTexture[id] = CalculateDensity(worldPos);
}

// TODO: rename cuz it's not just foam particles it's white particles comprised of spray, foam, bubbles
[numthreads(THREADGROUPSIZE, 1, 1)]
void UpdateFoamParticles(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if(i >= foamParticleCounts[0]) return;

    float3 pos = updatingFoamParticles[i].position;
    float dens = CalculateDensity(pos);

    // What type of particle is it this frame? TODO: To optimize could change classifications once every few frames or only do some particles per frame
    if(dens <= HighestSprayDensity) {
        UpdateSprayParticle(i, DeltaTime);
    } else if(dens >= LowestBubbleDensity) {
        UpdateBubbleParticle(i, DeltaTime);
    } else {
        UpdateFoamParticle(i, DeltaTime);
    }
}

[numthreads(THREADGROUPSIZE, 1, 1)]
void MoveSurvivingFoamParticlesToUpdatingBuffer(uint3 id : SV_DispatchThreadID) {
    uint i = id.x;
    if(i >= foamParticleCounts[1]) return;

    if(i == 0)
        foamParticleCounts[0] = foamParticleCounts[1];

    updatingFoamParticles[i] = survivingFoamParticles[i];
}